# Tutorial SpineOpt database

The optimization model [SpineOpt](https://github.com/Spine-tools/SpineOpt.jl) uses SpineOpt databases as its input. A SpineOpt database is a specific form of the spine database. In other words a SpineOpt database is a spine database but a spine database is not necessarily a SpineOpt database.

For this tutorial we will be using an existing database which can be found in the examples folder.

```julia
using SpineInterface

url="sqlite:///$(@__DIR__)/example_spineopt_database.sqlite"
using_spinedb(url)
```

!!! note
    The database file and the database that is loaded into Julia are not automatically synced. If you make changes through Julia, you need to save your changes with the `import_data` function. Similarly, if you made some changes in the database with the Spine Toolbox db editor, you need to reload the database into Julia.

The convenience functions that are generated by `using_spinedb` are now specific to the SpineOpt structure (units, nodes, connections, ...).

With these convenience functions we can navigate the database:
+ node() provides a list of the nodes
+ unit__to_node() provides a list of all the units that have flows to the node
+ unit__from_node() provides a list of all the units that have flows from the node
+ ...

!!! note
    __ is used as a name convention, e.g. dimension __ name


```julia
node()

    2-element Vector{Union{Int64, Object, TimeSlice}}:
        elec_finland
        elec_netherlands
```

From the nodes it seems that we are dealing with the electricity system in two countries.
Let's see if these nodes are supplied by power plants.
We do that by looking at all the relationships between the nodes and possible units connected to those nodes.

```julia
unit__to_node()

    3-element Vector{NamedTuple{K, V} where {K, V<:Tuple{Vararg{Union{Int64, Object, TimeSlice}}}}}:
        (unit = ccgt, node = elec_netherlands)
        (unit = pvfarm, node = elec_netherlands)
        (unit = windfarm, node = elec_finland)
```

Ok, that is great. But perhaps we do not want to query all possible power plants at the same time. We can pass some options to the query.

All the relationship classes accept three options:
+ no argument: you get all information, e.g. unit__to_node() gives a tuple of all the units and to which node they provide flow.
+ unit argument: information based on units, e.g. unit__to_node(unit=unit(:ccgt)) gives all nodes where unit ccgt provides flow to
+ node argument: information based on nodes, e.g. unit__to_node(node=node(:elec_finland)) gives all units that provide flow to the finland node

```julia
@show unit__to_node()
@show unit__to_node(unit=unit(:ccgt))
@show unit__to_node(node=node(:elec_finland))

    unit__to_node() = NamedTuple{K, V} where {K, V<:Tuple{Vararg{Union{Int64, Object, TimeSlice}}}}[(unit = ccgt, node = elec_netherlands), (unit = pvfarm, node = elec_netherlands), (unit = windfarm, node = elec_finland)]
    unit__to_node(unit = unit(:ccgt)) = Object[elec_netherlands]
    unit__to_node(node = node(:elec_finland)) = Object[windfarm]
```

We can access the node or unit information by calling them by their name as we did before but it is actually more common to use an iterator.

```julia
for u in unit()
    @show u
end

    u = ccgt
    u = pvfarm
    u = windfarm
```

```julia
for n in node()
    @show n,unit__to_node(node=n)
end

    (n, unit__to_node(node = n)) = (elec_finland, Object[windfarm])
    (n, unit__to_node(node = n)) = (elec_netherlands, Object[ccgt, pvfarm])
```

```julia
for n in node()
    @show n,connection__from_node(node=n)
end

    (n, connection__from_node(node = n)) = (elec_finland, Any[])
    (n, connection__from_node(node = n)) = (elec_netherlands, Object[interconnector])
```

```julia
for conn in connection()
    @show conn, connection__from_node(connection=conn)
end

    (conn, connection__from_node(connection = conn)) = (interconnector, Object[elec_netherlands])
```

These Objects and Relationships can have parameters associated to them. The easiest structure for a parameter is a direct value (e.g. 100). The most complex structure for a parameter is a Map. These parameters can be accessed from SpineInterface. Take for example the demand.

```julia
for n in node()
    @show n, demand(node=n)
end

    (n, demand(node = n)) = (elec_finland, Map{Dates.DateTime, Map{Symbol, TimeSeries{Float64}}}([Dates.DateTime("2000-01-01T00:00:00"), Dates.DateTime("2000-01-01T12:00:00")], Map{Symbol, TimeSeries{Float64}}[Map{Symbol, TimeSeries{Float64}}([:scen1, :scen2], TimeSeries{Float64}[TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[180.0,200.0](false,false)], Dict{Symbol, TimeSeries{Float64}}(:scen1 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), :scen2 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[180.0,200.0](false,false))), Map{Symbol, TimeSeries{Float64}}([:scen1, :scen2], TimeSeries{Float64}[TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[200.0,220.0](false,false)], Dict{Symbol, TimeSeries{Float64}}(:scen1 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), :scen2 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[200.0,220.0](false,false)))], Dict{Dates.DateTime, Map{Symbol, TimeSeries{Float64}}}(Dates.DateTime("2000-01-01T12:00:00") => Map{Symbol, TimeSeries{Float64}}([:scen1, :scen2], TimeSeries{Float64}[TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[200.0,220.0](false,false)], Dict{Symbol, TimeSeries{Float64}}(:scen1 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), :scen2 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[200.0,220.0](false,false))), Dates.DateTime("2000-01-01T00:00:00") => Map{Symbol, TimeSeries{Float64}}([:scen1, :scen2], TimeSeries{Float64}[TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[180.0,200.0](false,false)], Dict{Symbol, TimeSeries{Float64}}(:scen1 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), :scen2 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[180.0,200.0](false,false))))))
    (n, demand(node = n)) = (elec_netherlands, 100)
```

Some of the data will be linked to a variable and as such you will need to specify the indices of that variable.

The indices can consist of
+ nodes
+ scenarios
+ time

The indices can be accessed from SpineInterface as well.

```julia
indices(demand)
collect(indices(demand)) # makes it more readable

    2-element Vector{Object}:
        elec_finland
        elec_netherlands
```

For the time you can use the Dates package.

```julia
using Dates
demand(
    node=node(:elec_finland),
    t0=DateTime(2000, 1, 1, 12),
    s=stochastic_scenario(:scen2),
    t=DateTime(2000, 1, 1, 1)
)
# The time seems to go backwards but that is because the time in the database has accidentally been set backwards.

    220.0
```

So far we have only taken a look at the existing data but we can also write new data to the database.
Let's add a capacity to the pvfarm.

```julia
import_data(
    url,
    "load capacity value";
    relationship_parameters=[["unit__to_node","unit_capacity"]],
    relationship_parameter_values=[["unit__to_node", ["pvfarm", "elec_netherlands"], "unit_capacity", 40]],
)
```

!!! note
    Parameter values always have an alternative name.
    Alternative names are used for building scenarios in the SpineOpt model.
    By default any data added through a script gets a timestamp as an alternative name.
    However, the alternative name can also be specified.
    ```julia
    import_data(
        url,
        "load capacity value";
        relationship_parameters=[["unit__to_node","unit_capacity"]],
        relationship_parameter_values=[["unit__to_node", ["pvfarm", "elec_netherlands"], "unit_capacity", 40, "alt"]],
        alternatives=["alt"]	
    )
    ```

The full script can be found in the examples folder. The script also includes some example code for how these convenience functions can be used in a more complex function, e.g. to find all the isolated nodes (i.e. nodes without relationships).